#include  <stdint.h>
#include  <stdbool.h>
#include  <stdio.h>
#include  <string.h>
#include  <stdlib.h>
#include  <unistd.h>  // usleep

#include  "macro.h"
#include  "ansi.h"
#include  "conio.h"

#include  "tictac.h"
#include  "gfx.h"
#include  "build.h"
#include  "logic.h"
#include  "anal.h"
#include  "version.h"
#include  "bot.h"

#include  "debug.h"

#include  <time.h>
#include  <stdlib.h>

//----------------------------------------------------------------------------- ---------------------------------------
// global variables - extern'ed
//
global_s  g;

//+============================================================================ =======================================
// I hate duplicated code!
//
// when the current board contains `loop` pieces, we need to flip the parity
// the first time this will happen will be AFTER move #loop (eg. move #6) has been played
//
static  inline  void  parFlip(board_s* bp)  {  g.par ^= (bp->cnt == g.loop) && (bp->cnt != 9);  }

//+============================================================================ =======================================
int  tictac (void)
{
	board_s*  bp = &g.b[0];  // board #0 is the empty board

	// 'play' acts as the undo stack
	g.play[(g.move = 0, g.last = 0)].bp = bp;

	// In a normal game, the 6th move is ALWAYS player by player-2 ("X")
	// When a board loops (eg. move-6 -> move-6), we need to invert the roles of "player-1" and "player-2"
	// ie. if parity == 0, then when this board refers to a player as "player-1", it is referring to: "O"
	//     if parity == 1,  "    "    "     "      "   "  "    "   "  "player-1", "  "      "     " : "X"
	//
	// Similar is true for all looping games
	g.par = 0;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// GAME ON
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// === let's get this starty parted... ===
	int  in;  // input - generated by either a human or a bot

	for (g.move++;  ;  g.move++) {
		oxoBig(bp);  // Draw the main board

		parFlip(bp);  // maybe flip the parity for the Options

		// which children are in play ?   (standard, or loop)
		// {0..cnt-1} or {cnt..cCnt-1} ... the -1 is affected with `< nd` in the loops
		int  st = (bp->cnt == g.loop) ? (9 - bp->cnt) : 0 ;
		int  nd = (bp->cnt != g.loop) ? (9 - bp->cnt) : bp->cCnt ;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Opinion time...
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
swapSides:  // When the bot swaps/toggles sides mid-game
		in  = -1;  // No keyboard-or-mouse input/option/selection has been made

		// Start with all moves INVALIDated
		memset(g.pref, 0, sizeof(g.pref));
		for (int i = 0;  i < 9;  g.pref[i++].ink = C_INVALID) ;
		g.pref[9].ink = C_GAME;  // {9} is the game board 

		// Winners don't have children
		if (!bp->win) {
			analyse(bp, st, nd);

			// Bot to move?
			if (g.bot[g.botID].fn && ((g.move & 1) ^ g.botT))
				(void)g.bot[g.botID].fn(&in, st, nd);
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// User/Bot Input handling
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		// draw ALL children (even invalid moves)
		if (in == -1)  optShow(bp) ;

		// input move
		for (;;) {
			int  over = 0;  // game over status

			//----------------------------------------------
			// Evaluate game state and draw prompt
			//----------------------------------------------
			const char* const  icon1 = ((g.move & 1) ^ g.pl1) ? plo[0] : plx[0] ;  // this player
			const char* const  icon2 = ((g.move & 1) ^ g.pl1) ? plx[0] : plo[0] ;  // other player
			goyx(g.seqY+2,0);
			ink(NORM);
			if      (bp->win)          { MSGF("Player-%d %s WINS!\e[K", (g.move & 1) +1, icon2);  over = 1; }
			else if (bp->cnt == 9)     { MSGF("It's a draw!\e[K");                                over = 1; }
			else if (g.move > g.draw)  { MSGF("%d moves made - I declare a draw!\e[K", g.draw);   over = 1; }
			else                       { MSGF("Move %d: %s >\e[K", g.move, icon1);                          }

			//----------------------------------------------
			// Get user input
			//----------------------------------------------
			goyx(g.my, g.mx);  // position mouse
			if (in == -1) {    // -1 : bot did NOT generate input
				do {
					while (!kbhit())  usleep(1000) ;   // wait for a key (1mS == 1'000uS)
					in = getchw();                     // get the (wide-)key
				} while ((in == ',') || (in == ' ') || (in == '\r'));  // allow paste of previous game
			}

			//----------------------------------------------
			// Mouse input will simulate keystrokes
			//----------------------------------------------
			if (MOUSE_ISRPT(in)) {
				int  pos;

				// decode the event
				g.mev = MOUSE_EVENT(in);
				g.my  = MOUSE_Y(in);
				g.mx  = MOUSE_X(in);
//				MSGFYX(g.seqY+4,0, "Mouse: %3d @ %3d,%-3d", g.mev, g.my, g.mx);

				if (g.mev == MEV_POS) {
					if (!bp->win)  overkill(bp) ;  // overkill is the analysis-box/shadow-piece code ;)

				} else if ((g.mev == MEV_BTN_L) && MOUSE_ISDOWN(in)) {
					// -------------------------------------
					// game mode {5..9}
					int  m = modeChk();
					if (m) {
						if (g.bot[g.botID].loop == -1) {
							in     = KEY_CTRL_R;
							g.loop = m;
							analClr(-1);
							modeShow();
						}

					// -------------------------------------
					// bots
					} else if ((m = botChk()) != BOT_NONE) {
						// in/out of pvp - restart game
						if        ((m == BOT_PVP) && (g.botID != BOT_PVP)) {
							in = KEY_CTRL_R;

						} else if ((m != BOT_PVP) && (g.botID == BOT_PVP)) {
							in = KEY_CTRL_R;
						}
						botSet(m);
						menuShow();
						modeShow();
						botShow();

					// -------------------------------------
					// bot player {o, x, p}
					} else if (plmChk(&in) >= 0) {
						(void)NULL;

					// -------------------------------------
					// option {0..8} - by options
					} else if (optChk(&in) >= 0) {
						(void)NULL;

					// -------------------------------------
					// option {0..8} - by grid position
					} else if ((pos = oxoChk()) >= 0) {
						for (in = 8;  in >= 0;  in--)
							if (g.pref[in].ink == C_INVALID)           continue ;
							else if (pos == (bp->chld[in]->seq &0xF))  break ;
						in += '0';

					// -------------------------------------
					// menu options
					} else {
						switch (menuChk()) {
							case MNU_UNDO  :  in = KEY_LEFT;    break ;
							case MNU_REDO  :  in = KEY_RIGHT;   break ;
							case MNU_ANAL  :  in = g.bot[g.botID].fn ? KEY_CTRL_E : KEY_CTRL_A;  break ;
							case MNU_AGAIN :  in = KEY_CTRL_R;  break ;
							case MNU_QUIT  :  in = KEY_CTRL_C;  break ;
							default :  break ;
						}
					}

				// right-click : UNDO
				} else if ((g.mev == MEV_BTN_R) && MOUSE_ISDOWN(in)) {
					in = KEY_LEFT ;
				}
			}

			//----------------------------------------------
			// Special keys
			//----------------------------------------------
			// just one more retro-fitted bodge
			// turns ou the online game has X going first - so I had to fudge in some pl1_swap code
			if (g.pl1) {
				if      (in == 'x')  in = 'o' ;
				else if (in == 'o')  in = 'x' ;
			}

			if        (in == '`') {                             // ` (bactick) -> '0'
				in = '0';

			// -------------------------------------
			// jump to PvP mode without erasing the game
			} else if (in == KEY_CTRL_D) {                      // ^D debrief
				g.botID = BOT_PVP;
				botSet(g.botID);
				botShow();
				menuShow();

			// -------------------------------------
			} else if (in == '!') {                             // ! Swap who plays first
				g.pl1 ^= 1;
				plmShow();
				optShow(bp);
				oxoBig(bp);
				shadow(bp, -1, -1);
				overkill(bp);
				seqShow(g.move-1);

			} else if (in == KEY_CTRL_E) {                      // ^H hint show/hide [EASY]
				if (g.bot[g.botID].fn) {
					g.hint ^= 1;
					menuShow();

					// we draw the master board BEFORE we flipped the parity!
					g.par ^= (bp->cnt == g.loop);
					oxoBig(bp);  // Draw the main board
					g.par ^= (bp->cnt == g.loop);
				}

			} else if (in == KEY_CTRL_A) {                      // ^A analysis show/hide
				if (!g.bot[g.botID].fn) {
					g.hide ^= 1;
					optShow(bp);
					menuShow();

					// we draw the master board BEFORE we flipped the parity!
					parFlip(bp);
					oxoBig(bp);  // Draw the main board
					parFlip(bp);
				}

			} else if ((in == KEY_CTRL_C) || (in == KEY_CTRL_Q))  {  // ^C quit
				ink(NORM);
				MSGFYX(g.seqY+3,0, "Quit\e[K");
				return 0;

			} else if (KEY_ISALT(in)) {                         // Alt-? Chnge bot
				int  prev  = g.botID;
				int  reset = !((in & 0xFF) & 0x20);
				switch ((in|0x20) & 0xFF) {
					case 'p' :  g.botID = BOT_PVP   ;  break ;
					case 'j' :  g.botID = BOT_JACOB ;  break ;
					case 'c' :  g.botID = BOT_CABOT ;  break ;
					case 'd' :  g.botID = BOT_DAVID ;  break ;
					case 'w' :  g.botID = BOT_WATSON;  break ;
//					case 'f' :  g.botID = BOT_FALKEN;  break ;
					default  :  break ;
				}
				if (prev != g.botID) {
					botSet(g.botID);
					menuShow();
					modeShow();
					botShow();
					if (in & 0x20) {  // Use SHIFT to avoid a game reset ;)
						g.hide = 1;
						menuShow();
						seqClear();
						return 1;     // trigger reentry to tictac()
					}
				}

			} else if ((in == KEY_UP) || (in == KEY_DOWN)) {    // Change bot
				int  prev = g.botID;

				if (in == KEY_UP) {                             // up one
					if (INRANGE(g.botID, 2, BOT_CNT  ))  g.botID-- ;
				} else {                                        // down one
					if (INRANGE(g.botID, 1, BOT_CNT-2))  g.botID++ ;
				}

				if (prev != g.botID) {
					botSet(g.botID);
					menuShow();
					modeShow();
					botShow();
					g.hide = 1;
//! comment out these two lines - and you can change bot mid-game ;) [within limitations]
					seqClear();
					return 1;    // trigger reentry to tictac()
				}

			} else if (in == KEY_CTRL_R) {                      // ^R new game
				seqClear();
				return 1;    // trigger reentry to tictac()

			} else if ((in|0x20) == 'x') {                      // Bot is : X
				g.botT = 1;
				plmShow();
				if (!over)  goto swapSides;

			} else if ((in|0x20) == 'o') {                      // Bot is : O
				g.botT = 0;
				plmShow();
				if (!over)  goto swapSides;

			} else if ((in|0x20) == 'p') {                      // Toggle Bot player
				g.botT = !g.botT;
				plmShow();
				if (!over)  goto swapSides;

			} else if (in == KEY_RIGHT) {                       // -> redo
				if (g.last >= g.move) {
					in = g.play[g.move-1].in;
					goto redo;  // oh no, a scary goto! Quick: Call the 'goto' police!
				}

			} else if ( ((in == KEY_BKSP) || (in == KEY_LEFT))  // <-- undo : ASCII(DEL) [not ASCII(BS)]
			            && (g.move > 1) && (g.botID == BOT_PVP)) {
				// we want to end up on move-1, but the loop iterator does move++
				g.move -= 2;

				g.par  ^= (g.move+1 == g.loop);

				bp      = g.play[g.move].bp;
				seqShow(g.move);

				goto continue2;
			}

			//----------------------------------------------
			if (!over) {
				// valid move?
				in -= '0';                             // convert digit to value
				if ((in >= st) && (in < nd))  break ;  // valid move?
				if ((in >= 0 ) && (in <= 8))
					MSGFYX(g.seqY+3,0, "Bad move: %d\e[K", in);
			}

			in = -1;
		}

		// make the move!
		g.last              = g.move;        // update end of the redo-buffer
redo:
		g.play[g.move-1].in = in;            // mainboard option selected
		g.play[g.move].bp   = bp->chld[in];  // this selection (about to become mainboard)
		bp                  = bp->chld[in];  // board in play

		// Show move sequence
		seqShow(g.move);

		overkill(NULL);

continue2:
		MSGFYX(g.seqY+3,0, "\e[K");  // clear status line
	}//never exits

}

//+============================================================================ =======================================
void  cleanup (void)
{
	mouse(MRPT_NONE) ;
	(void)termRestore(NULL);
	goyx(g.seqY+5,1);
}

//++=========================================================================== =======================================
int main (int argc,  char* argv[])
{
	cls();

	srand(time(NULL));

	printf("# %s %s .. Copyright %s, %s\n", TOOLNAMES, VER_STR, AUTHOR, DATE);
//	printf("# Use: %s [5|6|7|8|9] [-a]\n", argv[0]);

	printf("# Game Keys: ");
	ink(BYEL);  printf(" !:Ply1{O,X} ");
	ink(BGRN);  printf(" ^Analysis ");
	ink(BYEL);  printf(" ^Restart ");
	ink(BGRN);  printf(" ^Quit ");
	ink(BYEL);  printf(" \u2191\u2193Bot ");
	ink(BGRN);  printf(" {o,x,p}:BotPiece ");
	ink(BYEL);  printf(" ^Easy ");
	ink(BGRN);  printf(" ^Debrief ");
	ink(BYEL);  printf(" \u2190Undo ");
	ink(BGRN);  printf(" \u2192Redo ");
	ink(NORM);  printf("\n");

	printf("# Analysis Key: ");
	ink(C_INVALID);  printf("invalid, ");
	ink(C_LOSE   );  printf("lose, ");
	ink(C_LOSE2  );  printf("lose-2, ");
	ink(C_WEAK   );  printf("weak, ");
	ink(C_FAIR   );  printf("fair, ");
	ink(C_STRONG );  printf("strong, ");
	ink(C_WIN2   );  printf("win-2, ");
	ink(C_WIN    );  printf("win");
	ink(NORM);       printf("\n");

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// initialise global variables
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	memset(&g, 0, sizeof(g));

	g.modeY = 11;  // game mode menu {6..9}
	g.modeX = 5;   // ...

	g.mnuY = 14;   // main menu
	g.mnuX = 5;    // ...

	g.plmY = 19;   // player menu
	g.plmX = 5;    // ...

	g.oxoY = 7;    // main board
	g.oxoX = 38;   // ...

	g.botY = 10;   // bot menu
	g.botX = 77;   // ...
	botSetup();
	g.botT = 1;    // Play as X

	g.optY = 26;   // y coord for options
	g.optW = 13;   // Width of an option

	g.seqY = 48;   // coord for sequence (other stuff below it)

	// game style :
	//   5 = the 'online' version
	//   6 = the 'electronic game' version
	//   7 = unknown
	//   8 = unknown
	//   9 = normal game
	g.loop   = 9;  // assume normal game

	g.unhide = 0;  // Bot debug .. 1 = ALWAYS show analysis

	g.hide   = 1;  // hide analysis & disable hints
	g.hint   = 0;  // enable hints in bot mode

	g.pl1    = 0;  // player-1 is {0->"O", 1->"X"}

	g.draw   = 36;  // draw after n moves

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// parse CLI (badly)
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for (int i = 1;  i < argc;  i++) {
		if      (strcmp(argv[i], "-?") == 0) {
			printf("  -5 .. -9   .. Game mode\n");
			printf("  -!         .. Player-1 => X\n");
			printf("  -a         .. Analysis display\n");
//			printf("  -b         .. Analysis display during PvB\n");
			printf("\n");
			printf("  -1         .. Bot goes first\n");
			printf("  -e         .. Easy mode (hints given)\n");
			printf("  +<N>       .. N = Number of moves to draw {9..%d}\n", MOVE_MAX);
			printf("\n");
			printf("  -J         .. Bot: Jacob\n");
			printf("  -C         .. Bot: Cabot\n");
			printf("  -D         .. Bot: David\n");
			printf("  -W         .. Bot: Watson\n");
//			printf("  -F         .. Bot: Falken\n");
			printf("\n");
			printf("  xogone.com .. Synonym for -5 -! -1 -W\n");
			printf("\n");
			exit(0);
		}
		else if (strcmp(argv[i], "-!") == 0)  g.pl1    = 1 ;  // player-1 -> X
		else if (strcmp(argv[i], "-1") == 0)  g.botT   = 0 ;  // bot goes first
		else if (strcmp(argv[i], "-e") == 0)  g.hint   = 1 ;  // hinting enabled

		else if (strcmp(argv[i], "-a") == 0)  g.hide   = 0 ;  // analysis displayed
		else if (strcmp(argv[i], "-b") == 0)  g.unhide = 1 ;  // enable bot analysis [hidden]

		else if (strcmp(argv[i], "-5") == 0)  g.loop   = 5 ;  // loop-5
		else if (strcmp(argv[i], "-6") == 0)  g.loop   = 6 ;  // loop-6
		else if (strcmp(argv[i], "-7") == 0)  g.loop   = 7 ;  // loop-7
		else if (strcmp(argv[i], "-8") == 0)  g.loop   = 8 ;  // loop-8
		else if (strcmp(argv[i], "-9") == 0)  g.loop   = 9 ;  // loop-9

		else if (strcmp(argv[i], "-J") == 0)  g.botID  = BOT_JACOB ;
		else if (strcmp(argv[i], "-C") == 0)  g.botID  = BOT_CABOT ;
		else if (strcmp(argv[i], "-D") == 0)  g.botID  = BOT_DAVID ;
		else if (strcmp(argv[i], "-W") == 0)  g.botID  = BOT_WATSON ;
//		else if (strcmp(argv[i], "-F") == 0)  g.loop   = BOT_FALKEN ;

		else if (*argv[i] == '+')  {
			g.draw = atoi(&argv[i][1]);
			if (!INRANGE(g.draw, 9, MOVE_MAX)) {
				printf("! draw range is: 9 .. %d\n", MOVE_MAX);
				exit(53);
			}
		}

		else if (strcmp(argv[i], "xogone.com") == 0) {
			g.loop  = 5;  // loop 5
			g.pl1   = 1;  // X goes first
			g.botT  = 0;  // Bot goes first
			g.botID = BOT_WATSON;
		}
	}

	//! bodge
	if (g.botID == BOT_JACOB)  g.loop = 9 ;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// build every possible game
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	printf("# Draw declared at %d moves\n", g.draw);

	printf("# Find complete solution set...\n");
	(void)build(9);
//.-	printf("%d possible game sequences\n", g.bn);

	printf("# Resolve loop points");
	// work out all the loop points
	for (int i = 5;  i <= 8;  i++) {
		printf(" @%d", i);
		fflush(stdout);
		loopat(i);
	}
	printf("\n");

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// game display
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	modeShow();
	menuShow();
	botShow();
	plmShow();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Configure everything
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// start keyboard driver (kills itself with atexit())
	kbdInit();

	(void)termSave(NULL);          // save window size
	(void)termSet(117, g.seqY+3);  // set window size

	(void)mouse(MRPT_ALL);         // enable mouse

	atexit(cleanup);               // cleanup when the program exits

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// run the game
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	while ( tictac() ) ;    // run the game until it returns 0

	return 0;
}
